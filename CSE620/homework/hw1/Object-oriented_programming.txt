   #alternate Edit this page Wikipedia (en) alternate copyright Wikipedia
   Atom feed

Object-oriented programming

   From Wikipedia, the free encyclopedia
   Jump to: navigation, search
   "Object-oriented" redirects here. For other meaning of object-oriented,
   see Object-orientation.
   Not to be confused with Object-based programming.
   "Object-oriented programming language" redirects here. For a list of
   object-oriented programming languages, see List of object-oriented
   programming languages.
   Ambox rewrite.svg
   This article may be in need of reorganization to comply with
   Wikipedia's layout guidelines. Please help by editing the article to
   make improvements to the overall structure. (November 2012)
             Programming paradigms
     * Action
     * Agent-oriented
     * Aspect-oriented
     * Automata-based
     * Concurrent computing
          + Relativistic programming
     * Data-driven
     * Declarative (contrast: Imperative)
          + Constraint
          + Dataflow
               o Flow-based
               o Cell-oriented (spreadsheets)
               o Reactive
          + Functional
               o Functional logic
          + Logic
               o Abductive logic
               o Answer set
               o Constraint logic
               o Functional logic
               o Inductive logic
     * End-user programming
     * Event-driven
          + Service-oriented
          + Time-driven
     * Expression-oriented
     * Feature-oriented
     * Function-level (contrast: Value-level)
     * Generic
     * Imperative (contrast: Declarative)
          + Procedural
     * Language-oriented
          + Natural language programming
          + Discipline-specific
          + Domain-specific
          + Grammar-oriented
               o Dialecting
          + Intentional
     * Metaprogramming
          + Automatic
          + Reflective
               o Attribute-oriented
          + Homoiconic
          + Template
               o Policy-based
     * Non-structured (contrast: Structured)
          + Array
     * Nondeterministic
     * Parallel computing
          + Process-oriented
     * Point-free style
          + Concatenative
     * Semantic
     * Structured (contrast: Non-structured)
          + Block-structured
          + Modular (contrast: Monolithic)
          + Object-oriented (OOP)
               o By separation of concerns:
                    # Aspect-oriented
                    # Role-oriented
                    # Subject-oriented
               o Class-based
               o Prototype-based
          + Recursive
     * Value-level (contrast: Function-level)
     * Probabilistic
     * Concept

     * v
     * t
     * e

   Object-oriented programming (OOP) is a programming style that
   represents the concept of "objects" that have data fields (attributes
   that describe the object) and associated procedures known as methods.
   Objects, which are usually instances of classes, are used to interact
   with one another to design applications and computer programs.^[1]^[2]
   C++, Objective-C, Smalltalk, Delphi, Java, Javascript, C#, Perl,
   Python, Ruby and PHP are examples of object-oriented programming
   languages.

Contents

     * 1 Overview
     * 2 History
     * 3 Fundamental features and concepts
          + 3.1 Decoupling
     * 4 Additional features
     * 5 Formal semantics
     * 6 OOP languages
          + 6.1 OOP in dynamic languages
     * 7 Design patterns
          + 7.1 Inheritance and behavioral subtyping
          + 7.2 Gang of Four design patterns
          + 7.3 Object-orientation and databases
          + 7.4 Real-world modeling and relationships
          + 7.5 OOP and control flow
          + 7.6 Responsibility- vs. data-driven design
     * 8 Criticism
     * 9 See also
     * 10 References
     * 11 Further reading
     * 12 External links

Overview[edit]

   Unbalanced scales.svg
   The neutrality of this section is disputed. Relevant discussion may be
   found on the talk page. Please do not remove this message until the
   dispute is resolved. (January 2014)

   Object-oriented programming attempts to provide a model for programming
   based on objects.^[3] Object-oriented programming integrates code and
   data using the concept of an "object". An object is an abstract data
   type with the addition of polymorphism and inheritance. An object has
   both state (data) and behavior (code).

   Objects sometimes correspond to things found in the real world. For
   example, a graphics program may have objects such as "circle,"
   "square," "menu." An online shopping system will have objects such as
   "shopping cart," "customer," and "product." The shopping system will
   support behaviors such as "place order," "make payment," and "offer
   discount."

   Objects are designed in class hierarchies. For example, with the
   shopping system there might be high level classes such as "electronics
   product," "kitchen product," and "book." There may be further
   refinements for example under "electronic products": "CD Player," "DVD
   player," etc. These classes and subclasses correspond to sets and
   subsets in mathematical logic. Rather than utilizing about database
   tables and programming subroutines, the developer utilizes objects the
   user may be more familiar with: objects from their application
   domain.^[4]

   Object orientation uses encapsulation and information hiding.
   Object-orientation essentially merges abstract data types with
   structured programming and divides systems into modular objects which
   own their own data and are responsible for their own behavior. This
   feature is known as encapsulation. With encapsulation, the data for two
   objects are divided so that changes to one object cannot affect the
   other. Note that all this relies on the various languages being used
   appropriately, which, of course, is never certain. Object-orientation
   is not a software silver bullet.^[5]

   The object-oriented approach encourages the programmer to place data
   where it is not directly accessible by the rest of the system. Instead,
   the data is accessed by calling specially written functions, called
   methods, which are bundled with the data. These act as the
   intermediaries for retrieving or modifying the data they control. The
   programming construct that combines data with a set of methods for
   accessing and managing that data is called an object. The practice of
   using subroutines to examine or modify certain kinds of data was also
   used in non-OOP modular programming, well before the widespread use of
   object-oriented programming.

   Defining software as modular components that support inheritance is
   meant to make it easy both to re-use existing components and to extend
   components as needed by defining new subclasses with specialized
   behaviors. This goal of being easy to both maintain and reuse is known
   in the object-oriented paradigm as the "open closed principle." A
   module is open if it supports extension (e.g. can easily modify
   behavior, add new properties, provide default values, etc.). A module
   is closed if it has a well defined stable interface that all other
   modules must use and that limits the interaction and potential errors
   that can be introduced into one module by changes in another.^[6]

History[edit]

   Terminology invoking "objects" and "oriented" in the modern sense of
   object-oriented programming made its first appearance at MIT in the
   late 1950s and early 1960s. In the environment of the artificial
   intelligence group, as early as 1960, "object" could refer to
   identified items (LISP atoms) with properties (attributes);^[7]^[8]
   Alan Kay was later to cite a detailed understanding of LISP internals
   as a strong influence on his thinking in 1966.^[9] Another early MIT
   example was Sketchpad created by Ivan Sutherland in 1960–61; in the
   glossary of the 1963 technical report based on his dissertation about
   Sketchpad, Sutherland defined notions of "object" and "instance" (with
   the class concept covered by "master" or "definition"), albeit
   specialized to graphical interaction.^[10] Also, an MIT ALGOL version,
   AED-0, linked data structures ("plexes", in that dialect) directly with
   procedures, prefiguring what were later termed "messages", "methods"
   and "member functions".^[11]^[12]

   The formal programming concept of objects was introduced in the 1960s
   in Simula 67, a major revision of Simula I, a programming language
   designed for discrete event simulation, created by Ole-Johan Dahl and
   Kristen Nygaard of the Norwegian Computing Center in Oslo.^[13] Simula
   67 was influenced by SIMSCRIPT and C.A.R. "Tony" Hoare's proposed
   "record classes".^[11]^[14] Simula introduced the notion of classes and
   instances or objects (as well as subclasses, virtual methods,
   coroutines, and discrete event simulation) as part of an explicit
   programming paradigm. The language also used automatic garbage
   collection that had been invented earlier for the functional
   programming language Lisp. Simula was used for physical modeling, such
   as models to study and improve the movement of ships and their content
   through cargo ports. The ideas of Simula 67 influenced many later
   languages, including Smalltalk, derivatives of LISP (CLOS), Object
   Pascal, and C++.

   The Smalltalk language, which was developed at Xerox PARC (by Alan Kay
   and others) in the 1970s, introduced the term object-oriented
   programming to represent the pervasive use of objects and messages as
   the basis for computation. Smalltalk creators were influenced by the
   ideas introduced in Simula 67, but Smalltalk was designed to be a fully
   dynamic system in which classes could be created and modified
   dynamically rather than statically as in Simula 67.^[15] Smalltalk and
   with it OOP were introduced to a wider audience by the August 1981
   issue of Byte Magazine.

   In the 1970s, Kay's Smalltalk work had influenced the Lisp community to
   incorporate object-based techniques that were introduced to developers
   via the Lisp machine. Experimentation with various extensions to Lisp
   (such as LOOPS and Flavors introducing multiple inheritance and mixins)
   eventually led to the Common Lisp Object System, which integrates
   functional programming and object-oriented programming and allows
   extension via a Meta-object protocol. In the 1980s, there were a few
   attempts to design processor architectures that included hardware
   support for objects in memory but these were not successful. Examples
   include the Intel iAPX 432 and the Linn Smart Rekursiv.

   In 1985, Bertrand Meyer produced the first design of the Eiffel
   language. Focused on software quality, Eiffel is among the purely
   object-oriented languages, but differs in the sense that the language
   itself is not only a programming language, but a notation supporting
   the entire software lifecycle. Meyer described the Eiffel software
   development method, based on a small number of key ideas from software
   engineering and computer science, in Object-Oriented Software
   Construction. Essential to the quality focus of Eiffel is Meyer's
   reliability mechanism, Design by Contract, which is an integral part of
   both the method and language.

   Object-oriented programming developed as the dominant programming
   methodology in the early and mid 1990s when programming languages
   supporting the techniques became widely available. These included
   Visual FoxPro 3.0,^[16]^[17]^[18] C++^[citation needed], and
   Delphi^[citation needed]. Its dominance was further enhanced by the
   rising popularity of graphical user interfaces, which rely heavily upon
   object-oriented programming techniques. An example of a closely related
   dynamic GUI library and OOP language can be found in the Cocoa
   frameworks on Mac OS X, written in Objective-C, an object-oriented,
   dynamic messaging extension to C based on Smalltalk. OOP toolkits also
   enhanced the popularity of event-driven programming (although this
   concept is not limited to OOP).

   At ETH Zürich, Niklaus Wirth and his colleagues had also been
   investigating such topics as data abstraction and modular programming
   (although this had been in common use in the 1960s or earlier).
   Modula-2 (1978) included both, and their succeeding design, Oberon,
   included a distinctive approach to object orientation, classes, and
   such.

   Object-oriented features have been added to many previously existing
   languages, including Ada, BASIC, Fortran, Pascal, and COBOL. Adding
   these features to languages that were not initially designed for them
   often led to problems with compatibility and maintainability of code.

   More recently, a number of languages have emerged that are primarily
   object-oriented, but that are also compatible with procedural
   methodology. Two such languages are Python and Ruby. Probably the most
   commercially-important recent object-oriented languages are Visual
   Basic.NET (VB.NET) and C#, both designed for Microsoft's .NET platform,
   and Java, developed by Sun Microsystems. Each of these two frameworks
   shows, in its own way, the benefit of using OOP by creating an
   abstraction from implementation. VB.NET and C# support cross-language
   inheritance, allowing classes defined in one language to subclass
   classes defined in the other language. Developers usually compile Java
   to bytecode, allowing Java to run on any operating system for which a
   Java virtual machine is available.

Fundamental features and concepts [edit]

   See also: List of object-oriented programming terms

   A survey by Deborah J. Armstrong of nearly 40 years of computing
   literature identified a number of fundamental concepts, found in the
   large majority of definitions of OOP.^[19]

   Not all of these concepts appear in all object-oriented programming
   languages. For example, object-oriented programming that uses classes
   is sometimes called class-based programming, while prototype-based
   programming does not typically use classes. As a result, a
   significantly different yet analogous terminology is used to define the
   concepts of object and instance.

   Benjamin C. Pierce and some other researchers view any attempt to
   distill OOP to a minimal set of features as futile. He nonetheless
   identifies fundamental features that support the OOP programming style
   in most object-oriented languages:^[20]
     * Dynamic dispatch – when a method is invoked on an object, the
       object itself determines what code gets executed by looking up the
       method at run time in a table associated with the object. This
       feature distinguishes an object from an abstract data type (or
       module), which has a fixed (static) implementation of the
       operations for all instances. It is a programming methodology that
       gives modular component development while at the same time being
       very efficient.
     * Encapsulation (or multi-methods, in which case the state is kept
       separate)
     * Subtype polymorphism
     * Object inheritance (or delegation)
     * Open recursion – a special variable (syntactically it may be a
       keyword), usually called this or self, that allows a method body to
       invoke another method body of the same object. This variable is
       late-bound; it allows a method defined in one class to invoke
       another method that is defined later, in some subclass thereof.

   Similarly, in his 2003 book, Concepts in programming languages, John C.
   Mitchell identifies four main features: dynamic dispatch, abstraction,
   subtype polymorphism, and inheritance.^[21] Michael Lee Scott in
   Programming Language Pragmatics considers only encapsulation,
   inheritance and dynamic dispatch.^[22]

   Additional concepts used in object-oriented programming include:
     * Classes of objects (object constructors)
     * Instances of classes (objects, which have been constructed via a
       class)
     * Methods which act on the attached objects.
     * Message passing
     * Abstraction

Decoupling[edit]

   Decoupling refers to careful controls that separate code modules from
   particular use cases, which increases code re-usability. A common use
   of decoupling is to polymorphically decouple the encapsulation (see
   bridge pattern and adapter pattern) – for example, using a method
   interface that an encapsulated object must satisfy, as opposed to using
   the object's class.

Additional features[edit]

   Encapsulation enforces modularity
          Encapsulation refers to the creation of self-contained modules
          that bind processing functions to the data. These user-defined
          data types are called "classes", and one instance of a class is
          an "object". For example, in a payroll system, a class could be
          Manager, and Pat and Jan could be two instances (two objects) of
          the Manager class. Encapsulation ensures good code modularity,
          which keeps routines separate and less prone to conflict with
          each other.

   Inheritance passes "knowledge" down
          Classes are created in hierarchies, and inheritance lets the
          structure and methods in one class pass down the hierarchy. That
          means less programming is required when adding functions to
          complex systems. If a step is added at the bottom of a
          hierarchy, only the processing and data associated with that
          unique step must be added. Everything else above that step is
          inherited. The ability to reuse existing objects is considered a
          major advantage of object technology.

   Polymorphism takes any shape
          Object-oriented programming lets programmers create procedures
          for objects whose exact type is not known until runtime. For
          example, a screen cursor may change its shape from an arrow to a
          line depending on the program mode. The routine to move the
          cursor on screen in response to mouse movement can be written
          for "cursor", and polymorphism lets that cursor take simulating
          system behaviour.

Formal semantics[edit]

   See also: Formal semantics of programming languages

   Objects are the run-time entities in an object-oriented system. They
   may represent a person, a place, a bank account, a table of data, or
   any item that the program has to handle.

   There have been several attempts at formalizing the concepts used in
   object-oriented programming. The following concepts and constructs have
   been used as interpretations of OOP concepts:
     * co algebraic data types^[23]
     * abstract data types (which have existential types) allow the
       definition of modules but these do not support dynamic dispatch
     * recursive types
     * encapsulated state
     * inheritance
     * records are basis for understanding objects if function literals
       can be stored in fields (like in functional programming languages),
       but the actual calculi need be considerably more complex to
       incorporate essential features of OOP. Several extensions of System
       F[<:] that deal with mutable objects have been studied;^[24] these
       allow both subtype polymorphism and parametric polymorphism
       (generics)

   Attempts to find a consensus definition or theory behind objects have
   not proven very successful (however, see Abadi & Cardelli, A Theory of
   Objects^[24] for formal definitions of many OOP concepts and
   constructs), and often diverge widely. For example, some definitions
   focus on mental activities, and some on program structuring. One of the
   simpler definitions is that OOP is the act of using "map" data
   structures or arrays that can contain functions and pointers to other
   maps, all with some syntactic and scoping sugar on top. Inheritance can
   be performed by cloning the maps (sometimes called "prototyping").

OOP languages[edit]

   Question book-new.svg
   This section does not cite any references or sources. Please help
   improve this section by adding citations to reliable sources. Unsourced
   material may be challenged and removed. (August 2009)
   See also: List of object-oriented programming languages

   Simula (1967) is generally accepted as the first language with the
   primary features of an object-oriented language. It was created for
   making simulation programs, in which what came to be called objects
   were the most important information representation. Smalltalk (1972 to
   1980) is arguably the canonical example, and the one with which much of
   the theory of object-oriented programming was developed. Concerning the
   degree of object orientation, the following distinctions can be made:
     * Languages called "pure" OO languages, because everything in them is
       treated consistently as an object, from primitives such as
       characters and punctuation, all the way up to whole classes,
       prototypes, blocks, modules, etc. They were designed specifically
       to facilitate, even enforce, OO methods. Examples: Eiffel,
       Emerald,^[25] JADE, Obix, Ruby, Scala, Smalltalk, Self.
     * Languages designed mainly for OO programming, but with some
       procedural elements. Examples: Delphi/Object Pascal, C++, Java, C#,
       VB.NET, Python.
     * Languages that are historically procedural languages, but have been
       extended with some OO features. Examples: Pascal, Visual Basic
       (derived from BASIC), MATLAB, Fortran, Perl, COBOL 2002, PHP, ABAP,
       Ada 95.
     * Languages with most of the features of objects (classes, methods,
       inheritance), but in a distinctly original form. Examples: Oberon
       (Oberon-1 or Oberon-2).
     * Languages with abstract data type support, but not all features of
       object-orientation, sometimes called object-based languages.
       Examples: Modula-2, Pliant, CLU.
     * Chameleon languages that support multiple paradigms, including OO.
       Tcl stands out among these for TclOO, a hybrid object system that
       supports both prototype-based programming and class-based OO.

OOP in dynamic languages[edit]

   In recent years, object-oriented programming has become especially
   popular in dynamic programming languages. Python, Ruby and Groovy are
   dynamic languages built on OOP principles, while Perl and PHP have been
   adding object-oriented features since Perl 5 and PHP 4, and ColdFusion
   since version 6.

   The Document Object Model of HTML, XHTML, and XML documents on the
   Internet has bindings to the popular JavaScript/ECMAScript language.
   JavaScript is perhaps the best known prototype-based programming
   language, which employs cloning from prototypes rather than inheriting
   from a class (contrast to class-based programming). Another scripting
   language that takes this approach is Lua. Before ActionScript 2.0 (a
   partial superset of the ECMA-262 R3, otherwise known as ECMAScript)
   only a prototype-based object model was supported.

Design patterns[edit]

   Challenges of object-oriented design are addressed by several
   methodologies. Most common is known as the design patterns codified by
   Gamma et al.. More broadly, the term "design patterns" can be used to
   refer to any general, repeatable solution to a commonly occurring
   problem in software design. Some of these commonly occurring problems
   have implications and solutions particular to object-oriented
   development.

Inheritance and behavioral subtyping[edit]

   See also: Object-oriented design

   It is intuitive to assume that inheritance creates a semantic "is a"
   relationship, and thus to infer that objects instantiated from
   subclasses can always be safely used instead of those instantiated from
   the superclass. This intuition is unfortunately false in most OOP
   languages, in particular in all those that allow mutable objects.
   Subtype polymorphism as enforced by the type checker in OOP languages
   (with mutable objects) cannot guarantee behavioral subtyping in any
   context. Behavioral subtyping is undecidable in general, so it cannot
   be implemented by a program (compiler). Class or object hierarchies
   must be carefully designed, considering possible incorrect uses that
   cannot be detected syntactically. This issue is known as the Liskov
   substitution principle.

Gang of Four design patterns[edit]

   Main article: Design pattern (computer science)

   Design Patterns: Elements of Reusable Object-Oriented Software is an
   influential book published in 1995 by Erich Gamma, Richard Helm, Ralph
   Johnson, and John Vlissides, often referred to humorously as the "Gang
   of Four". Along with exploring the capabilities and pitfalls of
   object-oriented programming, it describes 23 common programming
   problems and patterns for solving them. As of April 2007, the book was
   in its 36th printing.

   The book describes the following patterns:
     * Creational patterns (5): Factory method pattern, Abstract factory
       pattern, Singleton pattern, Builder pattern, Prototype pattern
     * Structural patterns (7): Adapter pattern, Bridge pattern, Composite
       pattern, Decorator pattern, Facade pattern, Flyweight pattern,
       Proxy pattern
     * Behavioral patterns (11): Chain-of-responsibility pattern, Command
       pattern, Interpreter pattern, Iterator pattern, Mediator pattern,
       Memento pattern, Observer pattern, State pattern, Strategy pattern,
       Template method pattern, Visitor pattern

Object-orientation and databases[edit]

   Main articles: Object-relational impedance mismatch, Object-relational
   mapping and Object database

   Both object-oriented programming and relational database management
   systems (RDBMSs) are extremely common in software today^[update]. Since
   relational databases don't store objects directly (though some RDBMSs
   have object-oriented features to approximate this), there is a general
   need to bridge the two worlds. The problem of bridging object-oriented
   programming accesses and data patterns with relational databases is
   known as object-relational impedance mismatch. There are a number of
   approaches to cope with this problem, but no general solution without
   downsides.^[26] One of the most common approaches is object-relational
   mapping, as found in libraries like Java Data Objects and Ruby on
   Rails' ActiveRecord.

   There are also object databases that can be used to replace RDBMSs, but
   these have not been as technically and commercially successful as
   RDBMSs.

Real-world modeling and relationships[edit]

   OOP can be used to associate real-world objects and processes with
   digital counterparts. However, not everyone agrees that OOP facilitates
   direct real-world mapping (see Criticism section) or that real-world
   mapping is even a worthy goal; Bertrand Meyer argues in Object-Oriented
   Software Construction^[27] that a program is not a model of the world
   but a model of some part of the world; "Reality is a cousin twice
   removed". At the same time, some principal limitations of OOP had been
   noted.^[28] For example, the Circle-ellipse problem is difficult to
   handle using OOP's concept of inheritance.

   However, Niklaus Wirth (who popularized the adage now known as Wirth's
   law: "Software is getting slower more rapidly than hardware becomes
   faster") said of OOP in his paper, "Good Ideas through the Looking
   Glass", "This paradigm closely reflects the structure of systems 'in
   the real world', and it is therefore well suited to model complex
   systems with complex behaviours" (contrast KISS principle).

   Steve Yegge and others noted that natural languages lack the OOP
   approach of strictly prioritizing things (objects/nouns) before actions
   (methods/verbs).^[29] This problem may cause OOP to suffer more
   convoluted solutions than procedural programming.^[30]

OOP and control flow[edit]

   OOP was developed to increase the reusability and maintainability of
   source code.^[31] Transparent representation of the control flow had no
   priority and was meant to be handled by a compiler. With the increasing
   relevance of parallel hardware and multithreaded coding, developing
   transparent control flow becomes more important, something hard to
   achieve with OOP.^[32]^[33]^[34]^[35]

Responsibility- vs. data-driven design[edit]

   Responsibility-driven design defines classes in terms of a contract,
   that is, a class should be defined around a responsibility and the
   information that it shares. This is contrasted by Wirfs-Brock and
   Wilkerson with data-driven design, where classes are defined around the
   data-structures that must be held. The authors hold that
   responsibility-driven design is preferable.

Criticism[edit]

   The OOP paradigm has been criticised for a number of reasons, including
   not meeting its stated goals of reusability and modularity,^[36]^[37]
   and for overemphasizing one aspect of software design and modeling
   (data/objects) at the expense of other important aspects
   (computation/algorithms).^[38]^[39]

   Luca Cardelli has claimed that OOP code is "intrinsically less
   efficient" than procedural code, that OOP can take longer to compile,
   and that OOP languages have "extremely poor modularity properties with
   respect to class extension and modification", and tend to be extremely
   complex.^[36] The latter point is reiterated by Joe Armstrong, the
   principal inventor of Erlang, who is quoted as saying:^[37]

     The problem with object-oriented languages is they've got all this
     implicit environment that they carry around with them. You wanted a
     banana but what you got was a gorilla holding the banana and the
     entire jungle.

   A study by Potok et al. has shown no significant difference in
   productivity between OOP and procedural approaches.^[40]

   Christopher J. Date stated that critical comparison of OOP to other
   technologies, relational in particular, is difficult because of lack of
   an agreed-upon and rigorous definition of OOP;^[41] however, Date and
   Darwen have proposed a theoretical foundation on OOP that uses OOP as a
   kind of customizable type system to support RDBMS.^[42]

   Alexander Stepanov compares object orientation unfavourably to
   multimethods:^[38]

     I find OOP technically unsound. It attempts to decompose the world
     in terms of interfaces that vary on a single type. To deal with the
     real problems you need multisorted algebras — families of interfaces
     that span multiple types. I find OOP philosophically unsound. It
     claims that everything is an object. Even if it is true it is not
     very interesting — saying that everything is an object is saying
     nothing at all.

   Paul Graham has suggested that OOP's popularity within large companies
   is due to "large (and frequently changing) groups of mediocre
   programmers." According to Graham, the discipline imposed by OOP
   prevents any one programmer from "doing too much damage."^[43]

   Steve Yegge noted that, as opposed to functional programming:^[44]

     Object Oriented Programming puts the Nouns first and foremost. Why
     would you go to such lengths to put one part of speech on a
     pedestal? Why should one kind of concept take precedence over
     another? It's not as if OOP has suddenly made verbs less important
     in the way we actually think. It's a strangely skewed perspective.

   Rich Hickey, creator of Clojure, described object systems as overly
   simplistic models of the real world. He emphasized the inability of OOP
   to model time properly, which is getting increasingly problematic as
   software systems become more concurrent.^[39]

   Eric S. Raymond, a Unix programmer and open-source software advocate,
   has been critical of claims that present object-oriented programming as
   the "One True Solution," and has written that object-oriented
   programming languages tend to encourage thickly-layered programs that
   destroy transparency.^[45] Raymond contrasts this to the approach taken
   with Unix and the C programming language.^[46]

See also[edit]

   This "see also" section may contain an excessive number of suggestions.
   Please ensure that only the most relevant suggestions are given and
   that they are not red links, and consider integrating suggestions into
   the article itself. (April 2014)
   Portal icon Computer programming portal
     * Aspect-oriented programming
     * CADES
     * Circle-ellipse problem
     * Comparison of programming languages (object-oriented programming)
     * Comparison of programming paradigms
     * Component-based software engineering
     * Concurrent object-oriented programming
     * Constructor (object-oriented programming)
     * Constructor overloading
     * CORBA
     * DCOM
     * Design by contract
     * GRASP
     * IDEF4
     * Interface-based programming
     * Interface description language
     * Jeroo
     * Lepus3
     * Modular programming
     * Object association
     * Object database
     * Object modeling language
     * Object-oriented analysis and design
     * Object-relational impedance mismatch (and The Third Manifesto)
     * Object-relational mapping
     * Procedural programming
     * Refactoring
     * SOLID
     * Structured programming
     * Visual FoxPro
     * ZZT-oop

References[edit]

    1. ^ Kindler, E.; Krivy, I. (2011). Object-Oriented Simulation of
       systems with sophisticated control. International Journal of
       General Systems. pp. 313–343.
    2. ^ Lewis, John; Loftus, William (2008). Java Software Solutions
       Foundations of Programming Design 6th ed. Pearson Education Inc.
       ISBN 0-321-53205-8. , section 1.6 "Object-Oriented Programming"
    3. ^ Booch, Grady (1986). Software Engineering with Ada. Addison
       Wesley. p. 220. ISBN 978-0805306088. "Perhaps the greatest strength
       of an object-oriented approach to development is that it offers a
       mechanism that captures a model of the real world."
    4. ^ Jacobsen, Ivar; Magnus Christerson; Patrik Jonsson; Gunnar
       Overgaard (1992). Object Oriented Software Engineering.
       Addison-Wesley ACM Press. pp. 43–69. ISBN 0-201-54435-0.
    5. ^ Brooks, Fred P. (April 1987). "No Silver Bullet — Essence and
       Accidents of Software Engineering". IEEE Computer 20 (4): 10–19.
    6. ^ Meyer, Bertrand (1988). Object-Oriented Software Construction.
       Cambridge: Prentice Hall International Series in Computer Science.
       p. 23. ISBN 0-13-629049-3.
    7. ^ McCarthy, J.; Brayton, R.; Edwards, D.; Fox, P.; Hodes, L.;
       Luckham, D.; Maling, K.; Park, D.; Russell, S. (March 1960). LISP I
       Programmers Manual. Boston, Massachusetts: Artificial Intelligence
       Group, M.I.T. Computation Center and Research Laboratory. p. 88f.
       "In the local M.I.T. patois, association lists [of atomic symbols]
       are also referred to as "property lists", and atomic symbols are
       sometimes called "objects"."
    8. ^ McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart,
       swapnil d.; Levin, Michael I. (1962). LISP 1.5 Programmer's Manual.
       MIT Press. p. 105. ISBN 0-262-13011-4. "Object — a synonym for
       atomic symbol"
    9. ^ "Dr. Alan Kay on the Meaning of "Object-Oriented Programming"".
       2003. Retrieved 11 February 2010.
   10. ^ Sutherland, I. E. (30 January 1963). "Sketchpad: A Man-Machine
       Graphical Communication System" (PDF). Technical Report No. 296,
       Lincoln Laboratory, Massachusetts Institute of Technology via
       Defense Technical Information Center (stinet.dtic.mil). Retrieved 3
       November 2007.
   11. ^ ^a ^b The Development of the Simula Languages, Kristen Nygaard,
       Ole-Johan Dahl, p.254 Uni-kl.ac.at
   12. ^ Ross, Doug. "The first software engineering language". LCS/AI Lab
       Timeline:. MIT Computer Science and Artificial Intelligence
       Laboratory. Retrieved 13 May 2010.
   13. ^ Holmevik, Jan Rune (1994). "Compiling Simula: A historical study
       of technological genesis". IEEE Annals of the History of Computing
       16 (4): 25–37. doi:10.1109/85.329756. Retrieved 12 May 2010.
   14. ^ Hoare, C. A. (Nov 1965). "Record Handling". ALGOL Bulletin (21):
       39–69. doi:10.1145/1061032.1061041.
   15. ^ Kay, Alan. "The Early History of Smalltalk". Retrieved 13
       September 2007.
   16. ^ 1995 (June) Visual FoxPro 3.0, FoxPro evolves from a procedural
       language to an object-oriented language. Visual FoxPro 3.0
       introduces a database container, seamless client/server
       capabilities, support for ActiveX technologies, and OLE Automation
       and null support. Summary of Fox releases
   17. ^ FoxPro History web site: Foxprohistory.org
   18. ^ 1995 Reviewers Guide to Visual FoxPro 3.0: DFpug.de
   19. ^ Armstrong, The Quarks of Object-Oriented Development. In
       descending order of popularity, the "quarks" are: Inheritance,
       Object, Class, Encapsulation, Method, Message Passing,
       Polymorphism, Abstraction
   20. ^ Pierce, Benjamin (2002). Types and Programming Languages. MIT
       Press. ISBN 0-262-16209-1. , section 18.1 "What is Object-Oriented
       Programming?"
   21. ^ John C. Mitchell, Concepts in programming languages, Cambridge
       University Press, 2003, ISBN 0-521-78098-5, p.278
   22. ^ Michael Lee Scott, Programming language pragmatics, Edition 2,
       Morgan Kaufmann, 2006, ISBN 0-12-633951-1, p. 470 vikas
   23. ^ Poll, Erik. "Subtyping and Inheritance for Categorical
       Datatypes". Retrieved 5 June 2011.
   24. ^ ^a ^b Abadi, Martin; Cardelli, Luca (1996). A Theory of Objects.
       Springer-Verlag New York, Inc. ISBN 0-387-94775-2. Retrieved 21
       April 2010.
   25. ^ "The Emerald Programming Language". 2011-02-26.
   26. ^ Neward, Ted (26 June 2006). "The Vietnam of Computer Science".
       Interoperability Happens. Retrieved 2 June 2010.
   27. ^ Meyer, Second Edition, p. 230
   28. ^ M.Trofimov, OOOP - The Third "O" Solution: Open OOP. First Class,
       OMG, 1993, Vol. 3, issue 3, p.14.
   29. ^ Yegge, Steve (30 March 2006). "Execution in the Kingdom of
       Nouns". steve-yegge.blogspot.com. Retrieved 3 July 2010.
   30. ^ Boronczyk, Timothy (11 June 2009). "What's Wrong with OOP".
       zaemis.blogspot.com. Retrieved 3 July 2010.
   31. ^ Ambler, Scott (1 January 1998). "A Realistic Look at
       Object-Oriented Reuse". www.drdobbs.com. Retrieved 4 July 2010.
   32. ^ Shelly, Asaf (22 August 2008). "Flaws of Object Oriented
       Modeling". Intel Software Network. Retrieved 4 July 2010.
   33. ^ James, Justin (1 October 2007). "Multithreading is a verb not a
       noun". techrepublic.com. Archived from the original on 2 January
       2013. Retrieved 4 July 2010.
   34. ^ Shelly, Asaf (22 August 2008). "HOW TO: Multicore Programming
       (Multiprocessing) Visual C++ Class Design Guidelines, Member
       Functions". support.microsoft.com. Retrieved 4 July 2010.
   35. ^ Robert Harper (17 April 2011). "Some thoughts on teaching FP".
       Existential Type Blog. Retrieved 5 December 2011.
   36. ^ ^a ^b Cardelli, Luca (1996). "Bad Engineering Properties of
       Object-Oriented Languages". ACM Comput. Surv. (ACM) 28 (4es): 150.
       doi:10.1145/242224.242415. ISSN 0360-0300. Retrieved 21 April
       2010.
   37. ^ ^a ^b Armstrong, Joe. In Coders at Work: Reflections on the Craft
       of Programming. Peter Seibel, ed. Codersatwork.com, Accessed 13
       November 2009.
   38. ^ ^a ^b Stepanov, Alexander. "STLport: An Interview with A.
       Stepanov". Retrieved 21 April 2010.
   39. ^ ^a ^b Rich Hickey, JVM Languages Summit 2009 keynote, Are We
       There Yet? November 2009.
   40. ^ Potok, Thomas; Mladen Vouk; Andy Rindos (1999). "Productivity
       Analysis of Object-Oriented Software Developed in a Commercial
       Environment". Software – Practice and Experience 29 (10): 833–847.
       doi:10.1002/(SICI)1097-024X(199908)29:10<833::AID-SPE258>3.0.CO;2-P
       . Retrieved 21 April 2010.
   41. ^ C. J. Date, Introduction to Database Systems, 6th-ed., Page 650
   42. ^ C. J. Date, Hugh Darwen. Foundation for Future Database Systems:
       The Third Manifesto (2nd Edition)
   43. ^ Graham, Paul. "Why ARC isn't especially Object-Oriented.".
       PaulGraham.com. Retrieved 13 November 2009.
   44. ^ Stevey's Blog Rants
   45. ^ Eric S. Raymond (2003). "The Art of Unix Programming: Unix and
       Object-Oriented Languages". Retrieved 2014-08-06.
   46. ^ Eric S. Raymond (2003). "The Art of Unix Programming: Unix and
       Object-Oriented Languages". Retrieved 2014-08-06.

Further reading[edit]

     * Abadi, Martin; Luca Cardelli (1998). A Theory of Objects. Springer
       Verlag. ISBN 0-387-94775-2.
     * Abelson, Harold; Gerald Jay Sussman, (1997). Structure and
       Interpretation of Computer Programs. MIT Press.
       ISBN 0-262-01153-0.  Cite uses deprecated parameters (help)
     * Armstrong, Deborah J. (February 2006). "The Quarks of
       Object-Oriented Development". Communications of the ACM 49 (2):
       123–128. doi:10.1145/1113034.1113040. ISSN 0001-0782. Retrieved 8
       August 2006.
     * Booch, Grady (1997). Object-Oriented Analysis and Design with
       Applications. Addison-Wesley. ISBN 0-8053-5340-2.
     * Eeles, Peter; Oliver Sims (1998). Building Business Objects. John
       Wiley & Sons. ISBN 0-471-19176-0.
     * Gamma, Erich; Richard Helm, Ralph Johnson, John Vlissides (1995).
       Design Patterns: Elements of Reusable Object Oriented Software.
       Addison-Wesley. ISBN 0-201-63361-2.  Cite uses deprecated
       parameters (help)
     * Harmon, Paul; William Morrissey (1996). The Object Technology
       Casebook - Lessons from Award-Winning Business Applications. John
       Wiley & Sons. ISBN 0-471-14717-6.
     * Jacobson, Ivar (1992). Object-Oriented Software Engineering: A Use
       Case-Driven Approach. Addison-Wesley. ISBN 0-201-54435-0.
     * Kay, Alan. The Early History of Smalltalk.
     * Meyer, Bertrand (1997). Object-Oriented Software Construction.
       Prentice Hall. ISBN 0-13-629155-4.
     * Pecinovsky, Rudolf (2013). OOP - Learn Object Oriented Thinking &
       Programming. Bruckner Publishing. ISBN 978-80-904661-8-0.
     * Rumbaugh, James; Michael Blaha; William Premerlani; Frederick Eddy;
       William Lorensen (1991). Object-Oriented Modeling and Design.
       Prentice Hall. ISBN 0-13-629841-9.
     * Schach, Stephen (2006). Object-Oriented and Classical Software
       Engineering, Seventh Edition. McGraw-Hill. ISBN 0-07-319126-4.
     * Schreiner, Axel-Tobias (1993). Object oriented programming with
       ANSI-C. Hanser. ISBN 3-446-17426-5. hdl:1850/8544.
     * Taylor, David A. (1992). Object-Oriented Information Systems -
       Planning and Implementation. John Wiley & Sons.
       ISBN 0-471-54364-0.
     * Weisfeld, Matt (2009). The Object-Oriented Thought Process, Third
       Edition. Addison-Wesley. ISBN 0-672-33016-4.

External links[edit]

   Wikiquote has quotations related to: Object-orientation
   Wikiversity has learning materials about Object-oriented programming at
   Topic:Object-Oriented Programming
   Wikibooks has a book on the topic of: Object Oriented Programming
     * Object-oriented programming at DMOZ
     * Chapter on implementing OOP in the programming language C by David
       Polberger
     * Introduction to Object Oriented Programming Concepts (OOP) and More
       by L.W.C. Nirosh
     * Discussion about the flaws of OOD
     * OOPS Concepts
     * OOP Concepts (Java Tutorials)
     * Intel blog - killing OOP


     * v
     * t
     * e

   Types of programming languages
     * Array
     * Aspect-oriented
     * Class-based
     * Concatenative
     * Concurrent
     * Data-structured
     * Dataflow
     * Declarative
     * Domain-specific
     * Dynamic
     * Esoteric
     * Event-driven
     * Extensible
     * Functional
     * Imperative
     * Logic
     * Macro
     * Metaprogramming
     * Multi-paradigm
     * Object-based
     * Object-oriented
     * Pipeline
     * Procedural
     * Prototype-based
     * Reflective
     * Rule-based
     * Scripting
     * Synchronous
     * Templating

     * Assembly
     * Compiled
     * Interpreted
     * Machine

     * Low-level
     * High-level
     * Very high-level

     * First generation
     * Second generation
     * Third generation
     * Fourth generation
     * Fifth generation

     * Non-English-based
     * Off-side rule
     * Visual


                    * v
     * t
     * e

   Software engineering
       Fields
                    * Computer programming
                    * Software requirements
                    * Software deployment
                    * Software design
                    * Software maintenance
                    * Software testing
                    * Systems analysis
                    * Formal methods

      Concepts
                    * Data modeling
                    * Enterprise architecture
                    * Functional specification
                    * Modeling language
                    * Orthogonality
                    * Programming paradigm
                    * Software
                    * Software architecture
                    * Software development methodology
                    * Software development process
                    * Software quality
                    * Software quality assurance
                    * Software archaeology
                    * Structured analysis

    Orientations
                    * Agile
                    * Aspect-oriented
                    * Object orientation
                    * Ontology
                    * Service orientation
                    * SDLC

       Models

                  Developmental
                                 * Agile
                                 * EUP
                                 * Executable UML
                                 * Incremental model
                                 * Iterative model
                                 * Prototype model
                                 * RAD
                                 * UP

                      Other
                                 * SPICE
                                 * CMMI
                                 * Data model
                                 * ER model
                                 * Function model
                                 * Information model
                                 * Metamodeling
                                 * Object model
                                 * Systems model
                                 * View model

                    Languages
                                 * IDEF
                                 * UML
                                 * SysML

      Software
   engineers
                    * Kent Beck
                    * Grady Booch
                    * Fred Brooks
                    * Barry Boehm
                    * Ward Cunningham
                    * Tom DeMarco
                    * Martin Fowler
                    * C. A. R. Hoare
                    * Watts Humphrey
                    * Michael A. Jackson
                    * Ivar Jacobson
                    * Stephen J. Mellor
                    * Bertrand Meyer
                    * David Parnas
                    * Winston W. Royce
                    * James Rumbaugh
                    * Niklaus Wirth
                    * Edward Yourdon
                    * Victor Basili
                    * Craig Larman

   Related fields
                    * Computer science
                    * Computer engineering
                    * Project management
                    * Systems engineering

     * Category Category
     * Commons

   Retrieved from
   "http://en.wikipedia.org/w/index.php?title=Object-oriented_programming&
   oldid=625521679"
   Categories:
     * Object-oriented programming
     * Programming paradigms

   Hidden categories:
     * Wikipedia articles needing reorganization from November 2012
     * NPOV disputes from January 2014
     * All NPOV disputes
     * All articles with unsourced statements
     * Articles with unsourced statements from April 2007
     * Articles with unsourced statements from February 2010
     * Articles needing additional references from August 2009
     * All articles needing additional references
     * Articles containing potentially dated statements from 2006
     * All articles containing potentially dated statements
     * Articles with excessive see also sections from April 2014
     * Pages containing cite templates with deprecated parameters
     * Articles with DMOZ links
     * Use dmy dates from September 2010

Navigation menu

Personal tools

     * Create account
     * Log in

Namespaces

     * Article
     * Talk

Variants

Views

     * Read
     * Edit
     * View history

More

Search

   ____________________ Search Go

Navigation

     * Main page
     * Contents
     * Featured content
     * Current events
     * Random article
     * Donate to Wikipedia
     * Wikimedia Shop

Interaction

     * Help
     * About Wikipedia
     * Community portal
     * Recent changes
     * Contact page

Tools

     * What links here
     * Related changes
     * Upload file
     * Special pages
     * Permanent link
     * Page information
     * Wikidata item
     * Cite this page

Print/export

     * Create a book
     * Download as PDF
     * Printable version

Languages

     * Afrikaans
     * العربية
     * Azərbaycanca
     * বাংলা
     * Беларуская
     * Беларуская (тарашкевіца)
     * Български
     * Bosanski
     * Català
     * Čeština
     * Dansk
     * Deutsch
     * Eesti
     * Ελληνικά
     * Español
     * Esperanto
     * Euskara
     * فارسی
     * Français
     * Galego
     * 한국어
     * Hrvatski
     * Ido
     * Ilokano
     * Bahasa Indonesia
     * Íslenska
     * Italiano
     * עברית
     * ქართული
     * Қазақша
     * Кыргызча
     * Latviešu
     * Lietuvių
     * Magyar
     * Македонски
     * മലയാളം
     * Bahasa Melayu
     * Монгол
     * မြန်မာဘာသာ
     * 日本語
     * Norsk bokmål
     * Norsk nynorsk
     * Polski
     * Română
     * Русиньскый
     * Русский
     * Scots
     * Shqip
     * Sicilianu
     * Simple English
     * Slovenčina
     * Српски / srpski
     * Srpskohrvatski / српскохрватски
     * Suomi
     * Svenska
     * தமிழ்
     * ไทย
     * Türkçe
     * Українська
     * اردو
     * Tiếng Việt
     * 吴语
     * 中文
     *

   Edit links

     * This page was last modified on 14 September 2014 at 13:54.
     * Text is available under the Creative Commons Attribution-ShareAlike
       License; additional terms may apply. By using this site, you agree
       to the Terms of Use and Privacy Policy. Wikipedia® is a registered
       trademark of the Wikimedia Foundation, Inc., a non-profit
       organization.

     * Privacy policy
     * About Wikipedia
     * Disclaimers
     * Contact Wikipedia
     * Developers
     * Mobile view

     * Wikimedia Foundation
     * Powered by MediaWiki
