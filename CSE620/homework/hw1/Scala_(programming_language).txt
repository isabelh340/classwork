   #alternate Edit this page Wikipedia (en) alternate copyright Wikipedia
   Atom feed

Scala (programming language)

   From Wikipedia, the free encyclopedia
   Jump to: navigation, search

   CAPTION: Scala

Scala logo.png
      Paradigm(s)       Multi-paradigm: functional, object-oriented, imperative,
                        concurrent
      Designed by       Martin Odersky
       Developer        Programming Methods Laboratory of École Polytechnique
                        Fédérale de Lausanne
      Appeared in       2003
    Stable release      2.11.2 / July 24, 2014 (2014-07-24)^[1]
    Preview release     2.11.0-RC4 / April 8, 2014 (2014-04-08)^[2]
   Typing discipline    static, strong, inferred, structural
     Influenced by      Eiffel, Erlang, Haskell,^[3] Java, Lisp,^[4] Pizza,^[5]
                        Standard ML, OCaml, Scheme, Smalltalk, Oz
      Influenced        Fantom, Ceylon, Lasso, Kotlin, Swift^[citation needed]
Implementation language Scala
       Platform         JVM, LLVM
        License         Scala License (similar to BSD license)
 Filename extension(s)  .scala
        Website         www.scala-lang.org
  * Scala at Wikibooks

   Scala (/ˈskɑːlə/ SKAH-lə)^[6] is an object-functional^[7] programming
   and scripting language^[8] for general software applications. Scala has
   full support for functional programming (including currying, pattern
   matching, algebraic data types, lazy evaluation, tail recursion,
   immutability, etc.) and a very strong static type system. This allows
   programs written in Scala to be very concise and thus smaller in size
   than most general purpose programming languages. Many of Scala's design
   decisions were inspired by criticism over the shortcomings of Java.^[5]

   Scala source code is intended to be compiled to Java bytecode, so that
   the resulting executable code runs on a Java virtual machine. Java
   libraries may be used directly in Scala code, and vice versa. Like
   Java, Scala is statically typed and object-oriented, and uses a
   curly-brace syntax reminiscent of the C programming language. Unlike
   Java, Scala has many features of functional programming languages like
   Scheme, Standard ML and Haskell, including anonymous functions, type
   inference, list comprehensions, and lazy initialization. Scala also has
   extensive language and library support for pattern matching, delimited
   continuations, higher-order types, covariance and contravariance, and
   for avoiding side-effects. Scala has a "unified type system", meaning
   that all types (including primitive types like integer and boolean) are
   subclasses of the type Any. This is similar to C# but unlike Java.
   Scala likewise has other features present in C# but not Java, including
   anonymous types, operator overloading, optional parameters, named
   parameters, raw strings, and no checked exceptions.

   The name Scala is a portmanteau of "scalable" and "language",
   signifying that it is designed to grow with the demands of its users.

Contents

     * 1 History
     * 2 Platforms and license
     * 3 Examples
          + 3.1 "Hello World" example
          + 3.2 A basic example
          + 3.3 An example with classes
     * 4 Features (with reference to Java)
          + 4.1 Syntactic flexibility
          + 4.2 Unified type system
          + 4.3 For-expressions
          + 4.4 Functional tendencies
               o 4.4.1 Everything is an expression
               o 4.4.2 Type inference
               o 4.4.3 Anonymous functions
               o 4.4.4 Immutability
               o 4.4.5 Lazy (non-strict) evaluation
               o 4.4.6 Tail recursion
               o 4.4.7 Case classes and pattern matching
               o 4.4.8 Partial functions
          + 4.5 Object-oriented extensions
          + 4.6 Expressive type system
          + 4.7 Type enrichment
     * 5 Concurrency
     * 6 Cluster computing
     * 7 Testing
     * 8 Versions
     * 9 Comparison with other JVM languages
     * 10 Adoption
          + 10.1 Language rankings
          + 10.2 Companies
          + 10.3 Criticism
     * 11 See also
     * 12 References
     * 13 Further reading
     * 14 External links

History[edit]

   The design of Scala started in 2001 at the École Polytechnique Fédérale
   de Lausanne (EPFL) by Martin Odersky, following on from work on Funnel,
   a programming language combining ideas from functional programming and
   Petri nets.^[9] Odersky had previously worked on Generic Java and
   javac, Sun's Java compiler.^[9]

   Scala was released internally in late 2003, before being released
   publicly in early 2004 on the Java platform,^[10] and on the .NET
   platform in June 2004.^[5]^[9]^[11] A second version of the language,
   v2.0, was released in March 2006.^[5] The .NET support was officially
   dropped in 2012.^[12]

   On 17 January 2011 the Scala team won a five-year research grant of
   over €2.3 million from the European Research Council.^[13] On 12 May
   2011, Odersky and collaborators launched Typesafe Inc., a company to
   provide commercial support, training, and services for Scala. Typesafe
   received a $3 million investment from Greylock
   Partners.^[14]^[15]^[16]^[17]

Platforms and license[edit]

   Scala runs on the Java platform (Java Virtual Machine) and is
   compatible with existing Java programs.^[10] It also runs on Android
   smartphones.^[18]

   The Scala software distribution, including compiler and libraries, is
   released under a BSD license.^[19]

Examples[edit]

"Hello World" example[edit]

   The Hello World program written in Scala has this form:
 object HelloWorld extends App {
   println("Hello, World!")
 }

   Unlike the stand-alone Hello World application for Java, there is no
   class declaration and nothing is declared to be static; a singleton
   object created with the object keyword is used instead.

   With the program saved in a file named HelloWorld.scala, it can be
   compiled from the command line:

   $ scalac HelloWorld.scala

   To run it:

   $ scala HelloWorld (You may need to use the "-cp" key to set the
   classpath like in Java).

   This is analogous to the process for compiling and running Java code.
   Indeed, Scala's compilation and execution model is identical to that of
   Java, making it compatible with Java build tools such as Ant.

   A shorter version of the "Hello World" Scala program is:
println("Hello, World!")

   Saved in a file named HelloWorld2.scala, this can be run as a script
   without prior compilation using:

   $ scala HelloWorld2.scala

   Commands can also be entered directly into the Scala interpreter, using
   the option -e:

   $ scala -e 'println("Hello, World!")'

A basic example[edit]

   The following example shows the differences between Java and Scala
   syntax:
// Java:
int mathFunction(int num) {
    int numSquare = num*num;
    return (int) (Math.cbrt(numSquare) +
      Math.log(numSquare));
}

// Scala: Direct conversion from Java

// no import needed; scala.math
// already imported as `math`
def mathFunction(num: Int): Int = {
  var numSquare: Int = num*num
  return (math.cbrt(numSquare) + math.log(numSquare)).
    asInstanceOf[Int]
}

// Scala: More idiomatic
// Uses type inference, omits `return` statement,
// uses `toInt` method

import math._
def intRoot23(num: Int) = {
  val numSquare = num*num
  (cbrt(numSquare) + log(numSquare)).toInt
}

   Some syntactic differences in this code are:
     * Scala does not require semicolons to end statements.
     * Value types are capitalized: Int, Double, Boolean instead of int,
       double, boolean.
     * Parameter and return types follow, as in Pascal, rather than
       precede as in C.
     * Functions must be preceded by def.
     * Local or class variables must be preceded by val (indicates an
       immutable variable) or var (indicates a mutable variable).
     * The return operator is unnecessary in a function (although
       allowed); the value of the last executed statement or expression is
       normally the function's value.
     * Instead of the Java cast operator (Type) foo, Scala uses
       foo.asInstanceOf[Type], or a specialized function such as toDouble
       or toInt.
     * Instead of Java's import foo.*;, Scala uses import foo._.
     * Function or method foo() can also be called as just foo; method
       thread.send(signo) can also be called as just thread send signo;
       and method foo.toString() can also be called as just foo toString.

   These syntactic relaxations are designed to allow support for
   domain-specific languages.

   Some other basic syntactic differences:
     * Array references are written like function calls, e.g. array(i)
       rather than array[i]. (Internally in Scala, both arrays and
       functions are conceptualized as kinds of mathematical mappings from
       one object to another.)
     * Generic types are written as e.g. List[String] rather than Java's
       List<String>.
     * Instead of the pseudo-type void, Scala has the actual singleton
       class Unit (see below).

An example with classes[edit]

   The following example contrasts the definition of classes in Java and
   Scala.
// Java:
public class Point {
  private final double x, y;

  public Point(final double X, final double Y) {
    x = X;
    y = Y;
  }

  public double getX() {
    return x;
  }

  public double getY() {
    return y;
  }

  public Point(
    final double X, final double Y,
    final boolean ADD2GRID
  ) {
    this(X, Y);

    if (ADD2GRID)
      grid.add(this);
  }

  public Point() {
    this(0.0, 0.0);
  }

  double distanceToPoint(final Point OTHER) {
    return distanceBetweenPoints(x, y,
      OTHER.x, OTHER.y);
  }

  private static Grid grid = new Grid();

  static double distanceBetweenPoints(
      final double X1, final double Y1,
      final double X2, final double Y2
  ) {
    return Math.hypot(X1 - X2, Y1 - Y2);
  }
}

// Scala
class Point(
    val x: Double, val y: Double,
    addToGrid: Boolean = false
) {
  import Point._

  if (addToGrid)
    grid.add(this)

  def this() = this(0.0, 0.0)

  def distanceToPoint(other: Point) =
    distanceBetweenPoints(x, y, other.x, other.y)
}

object Point {
  private val grid = new Grid()

  def distanceBetweenPoints(x1: Double, y1: Double,
      x2: Double, y2: Double) = {
    math.hypot(x1 - x2, y1 - y2)
  }
}

   The above code shows some of the conceptual differences between Java
   and Scala's handling of classes:
     * Scala has no static variables or methods. Instead, it has singleton
       objects, which are essentially classes with only one object in the
       class. Singleton objects are declared using object instead of
       class. It is common to place static variables and methods in a
       singleton object with the same name as the class name, which is
       then known as a companion object.^[10] (The underlying class for
       the singleton object has a $ appended. Hence, for class Foo with
       companion object object Foo, under the hood there's a class Foo$
       containing the companion object's code, and a single object of this
       class is created, using the singleton pattern.)
     * In place of constructor parameters, Scala has class parameters,
       which are placed on the class itself, similar to parameters to a
       function. When declared with a val or var modifier, fields are also
       defined with the same name, and automatically initialized from the
       class parameters. (Under the hood, external access to public fields
       always goes through accessor (getter) and mutator (setter) methods,
       which are automatically created. The accessor function has the same
       name as the field, which is why it's unnecessary in the above
       example to explicitly declare accessor methods.) Note that
       alternative constructors can also be declared, as in Java. Code
       that would go into the default constructor (other than initializing
       the member variables) goes directly at class level.
     * Default visibility in Scala is public.

Features (with reference to Java)[edit]

   Scala has the same compilation model as Java and C#, namely separate
   compilation and dynamic class loading, so that Scala code can call Java
   libraries, or .NET libraries in the .NET implementation.

   Scala's operational characteristics are the same as Java's. The Scala
   compiler generates byte code that is nearly identical to that generated
   by the Java compiler.^[10] In fact, Scala code can be decompiled to
   readable Java code, with the exception of certain constructor
   operations. To the JVM, Scala code and Java code are indistinguishable.
   The only difference is a single extra runtime library,
   scala-library.jar.^[20]

   Scala adds a large number of features compared with Java, and has some
   fundamental differences in its underlying model of expressions and
   types, which make the language theoretically cleaner and eliminate a
   number of "corner cases" in Java. From the Scala perspective, this is
   practically important because a number of additional features in Scala
   are also available in C#. Examples include:

Syntactic flexibility[edit]

   As mentioned above, Scala has a good deal of syntactic flexibility,
   compared with Java. The following are some examples:
     * Semicolons are unnecessary; lines are automatically joined if they
       begin or end with a token that cannot normally come in this
       position, or if there are unclosed parentheses or brackets.
     * Any method can be used as an infix operator, e.g. "%d
       apples".format(num) and "%d apples" format num are equivalent. In
       fact, arithmetic operators like + and << are treated just like any
       other methods, since function names are allowed to consist of
       sequences of arbitrary symbols (with a few exceptions made for
       things like parens, brackets and braces that must be handled
       specially); the only special treatment that such symbol-named
       methods undergo concerns the handling of precedence.
     * Methods apply and update have syntactic short forms. foo()—where
       foo is a value (singleton object or class instance)—is short for
       foo.apply(), and foo() = 42 is short for foo.update(42). Similarly,
       foo(42) is short for foo.apply(42), and foo(4) = 2 is short for
       foo.update(4, 2). This is used for collection classes and extends
       to many other cases, such as STM cells.
     * Scala distinguishes between no-parens (def foo = 42) and
       empty-parens (def foo() = 42) methods. When calling an empty-parens
       method, the parentheses may be omitted, which is useful when
       calling into Java libraries which do not know this distinction,
       e.g., using foo.toString instead of foo.toString(). By convention a
       method should be defined with empty-parens when it performs side
       effects.
     * Method names ending in colon (:) expect the argument on the
       left-hand-side and the receiver on the right-hand-side. For
       example, the 4 :: 2 :: Nil is the same as Nil.::(2).::(4), the
       first form corresponding visually to the result (a list with first
       element 4 and second element 2).
     * Class body variables can be transparently implemented as separate
       getter and setter methods. For trait FooLike { var bar: Int }, an
       implementation may be object Foo extends FooLike { private var x =
       0; def bar = x; def bar_=(value: Int) { x = value }}. The call site
       will still be able to use a concise foo.bar = 42.
     * The use of curly braces instead of parentheses is allowed in method
       calls. This allows pure library implementations of new control
       structures.^[21] For example, breakable { ... if (...) break() ...
       } looks as if breakable was a language defined keyword, but really
       is just a method taking a thunk argument. Methods that take thunks
       or functions often place these in a second parameter list, allowing
       to mix parentheses and curly braces syntax: Vector.fill(4) {
       math.random } is the same as Vector.fill(4)(math.random). The curly
       braces variant allows the expression to span multiple lines.
     * For-expressions (explained further down) can accommodate any type
       that defines monadic methods such as map, flatMap and filter.

   By themselves, these may seem like questionable choices, but
   collectively they serve the purpose of allowing domain-specific
   languages to be defined in Scala without needing to extend the
   compiler. For example, Erlang's special syntax for sending a message to
   an actor, i.e. actor ! message can be (and is) implemented in a Scala
   library without needing language extensions.

Unified type system[edit]

   Java makes a sharp distinction between primitive types (e.g. int and
   boolean) and reference types (any class). Only reference types are part
   of the inheritance scheme, deriving from java.lang.Object. In Scala,
   however, all types inherit from a top-level class Any, whose immediate
   children are AnyVal (value types, such as Int and Boolean) and AnyRef
   (reference types, as in Java). This means that the Java distinction
   between primitive types and boxed types (e.g. int vs. Integer) is not
   present in Scala; boxing and unboxing is completely transparent to the
   user. Scala 2.10 allows for new value types to be defined by the user.

For-expressions[edit]

   Instead of the Java "foreach" loops for looping through an iterator,
   Scala has a much more powerful concept of for-expressions. These are
   similar to list comprehensions in languages such as Haskell, or a
   combination of list comprehensions and generator expressions in Python.
   For-expressions using the yield keyword allow a new collection to be
   generated by iterating over an existing one, returning a new collection
   of the same type. They are translated by the compiler into a series of
   map, flatMap and filter calls. Where yield is not used, the code
   approximates to an imperative-style loop, by translating to foreach.

   A simple example is:
val s = for (x <- 1 to 25 if x*x > 50) yield 2*x

   The result of running it is the following vector:

          Vector(16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
          44, 46, 48, 50)

   (Note that the expression 1 to 25 is not special syntax. The method to
   is rather defined in the standard Scala library as an extension method
   on integers, using a technique known as implicit conversions^[22] that
   allows new methods to be added to existing types.)

   A more complex example of iterating over a map is:
// Given a map specifying Twitter users mentioned in a set of tweets,
// and number of times each user was mentioned, look up the users
// in a map of known politicians, and return a new map giving only the
// Democratic politicians (as objects, rather than strings).
val dem_mentions = for {
    (mention, times) <- mentions
    account          <- accounts.get(mention)
    if account.party == "Democratic"
  } yield (account, times)

   Expression (mention, times) <- mentions is an example of pattern
   matching (see below). Iterating over a map returns a set of key-value
   tuples, and pattern-matching allows the tuples to easily be
   destructured into separate variables for the key and value. Similarly,
   the result of the comprehension also returns key-value tuples, which
   are automatically built back up into a map because the source object
   (from the variable mentions) is a map. Note that if mentions instead
   held a list, set, array or other collection of tuples, exactly the same
   code above would yield a new collection of the same type.

Functional tendencies[edit]

   While supporting all of the object-oriented features available in Java
   (and in fact, augmenting them in various ways), Scala also provides a
   large number of capabilities that are normally found only in functional
   programming languages. Together, these features allow Scala programs to
   be written in an almost completely functional style, and also allow
   functional and object-oriented styles to be mixed.

   Examples are:
     * No distinction between statements and expressions
     * Type inference
     * Anonymous functions with capturing semantics (i.e. closures)
     * Immutable variables and objects
     * Lazy evaluation
     * Delimited continuations (since 2.8)
     * Higher-order functions
     * Nested functions
     * Currying
     * Pattern matching
     * Algebraic data types (through "case classes")
     * Tuples

Everything is an expression[edit]

   Question book-new.svg
   This section does not cite any references or sources. Please help
   improve this section by adding citations to reliable sources. Unsourced
   material may be challenged and removed. (June 2013)

   Unlike C or Java, but similar to languages such as Lisp, Scala makes no
   distinction between statements and expressions. All statements are in
   fact expressions that evaluate to some value. Functions that would be
   declared as returning void in C or Java, and statements like while that
   logically do not return a value, are in Scala considered to return the
   type Unit, which is a singleton type, with only one object of that
   type. Functions and operators that never return at all (e.g. the throw
   operator or a function that always exits non-locally using an
   exception) logically have return type Nothing, a special type
   containing no objects; that is, a bottom type, i.e. a subclass of every
   possible type. (This in turn makes type Nothing compatible with every
   type, allowing type inference to function correctly.)

   Similarly, an if-then-else "statement" is actually an expression, which
   produces a value, i.e. the result of evaluating one of the two
   branches. This means that such a block of code can be inserted wherever
   an expression is desired, obviating the need for a ternary operator in
   Scala:
// Java:
int hexDigit = x >= 10 ? x + 'A' - 10 : x + '0';

// Scala:
val hexDigit = if (x >= 10) x + 'A' - 10 else x + '0'

   For similar reasons, return statements are unnecessary in Scala, and in
   fact are discouraged. As in Lisp, the last expression in a block of
   code is the value of that block of code, and if the block of code is
   the body of a function, it will be returned by the function.

   To make it clear that all expressions are functions, even methods that
   return Unit are written with an equals sign
def printValue(x: String): Unit = {
  println("I ate a %s".format(x))
}

   or equivalently (with type inference, and omitting the unnecessary
   braces):
def printValue(x: String) = println("I ate a %s" format x)

Type inference[edit]

   Due to type inference, the type of variables, function return values,
   and many other expressions can typically be omitted, as the compiler
   can deduce it. Examples are val x = "foo" (for an immutable, constant
   variable or immutable object) or var x = 1.5 (for a variable whose
   value can later be changed). Type inference in Scala is essentially
   local, in contrast to the more global Hindley-Milner algorithm used in
   Haskell, ML and other more purely functional languages. This is done to
   facilitate object-oriented programming. The result is that certain
   types still need to be declared (most notably, function parameters, and
   the return types of recursive functions), e.g.
def formatApples(x: Int) = "I ate %d apples".format(x)

   or (with a return type declared for a recursive function)
def factorial(x: Int): Int =
  if (x == 0)
    1
  else
    x*factorial(x - 1)

Anonymous functions[edit]

   In Scala, functions are objects, and a convenient syntax exists for
   specifying anonymous functions. An example is the expression x => x <
   2, which specifies a function with a single parameter, that compares
   its argument to see if it is less than 2. It is equivalent to the Lisp
   form (lambda (x) (< x 2)). Note that neither the type of x nor the
   return type need be explicitly specified, and can generally be inferred
   by type inference; but they can be explicitly specified, e.g. as (x:
   Int) => x < 2 or even (x: Int) => (x < 2): Boolean.

   Anonymous functions behave as true closures in that they automatically
   capture any variables that are lexically available in the environment
   of the enclosing function. Those variables will be available even after
   the enclosing function returns, and unlike in the case of Java's
   "anonymous inner classes" do not need to be declared as final. (It is
   even possible to modify such variables if they are mutable, and the
   modified value will be available the next time the anonymous function
   is called.)

   An even shorter form of anonymous function uses placeholder variables:
   For example, the following:

          list map { x => sqrt(x) }

   can be written more concisely as

          list map { sqrt(_) }

   or even

          list map sqrt

Immutability[edit]

   Scala enforces a distinction between immutable (unmodifiable,
   read-only) variables, whose value cannot be changed once assigned, and
   mutable variables, which can be changed. A similar distinction is made
   between immutable and mutable objects. The distinction must be made
   when a variable is declared: Immutable variables are declared with val
   while mutable variables use var. Similarly, all of the collection
   objects (container types) in Scala, e.g. linked lists, arrays, sets and
   hash tables, are available in mutable and immutable variants, with the
   immutable variant considered the more basic and default implementation.
   The immutable variants are "persistent" data types in that they create
   a new object that encloses the old object and adds the new member(s);
   this is similar to how linked lists are built up in Lisp, where
   elements are prepended by creating a new "cons" cell with a pointer to
   the new element (the "head") and the old list (the "tail"). This allow
   for very easy concurrency — no locks are needed as no shared objects
   are ever modified. Immutable structures are also constructed
   efficiently, in the sense that modified instances reuses most of old
   instance data and unused/unreferenced parts are collected by GC.^[23]

Lazy (non-strict) evaluation[edit]

   Evaluation is strict ("eager") by default. In other words, Scala
   evaluates expressions as soon as they are available, rather than as
   needed. However, you can declare a variable non-strict ("lazy") with
   the lazy keyword, meaning that the code to produce the variable's value
   will not be evaluated until the first time the variable is referenced.
   Non-strict collections of various types also exist (such as the type
   Stream, a non-strict linked list), and any collection can be made
   non-strict with the view method. Non-strict collections provide a good
   semantic fit to things like server-produced data, where the evaluation
   of the code to generate later elements of a list (that in turn triggers
   a request to a server, possibly located somewhere else on the web) only
   happens when the elements are actually needed.

Tail recursion[edit]

   Functional programming languages commonly provide tail call
   optimization to allow for extensive use of recursion without stack
   overflow problems. Limitations in Java bytecode complicate tail call
   optimization on the JVM. In general, a function that calls itself with
   a tail call can be optimized, but mutually recursive functions cannot.
   Trampolines have been suggested as a workaround.^[24] Trampoline
   support has been provided by the Scala library with the object
   scala.util.control.TailCalls since Scala 2.8.0 (released July 14,
   2010).^[25]

Case classes and pattern matching[edit]

   Scala has built-in support for pattern matching, which can be thought
   of as a more sophisticated, extensible version of a switch statement,
   where arbitrary data types can be matched (rather than just simple
   types like integers, booleans and strings), including arbitrary
   nesting. A special type of class known as a case class is provided,
   which includes automatic support for pattern matching and can be used
   to model the algebraic data types used in many functional programming
   languages. (From the perspective of Scala, a case class is simply a
   normal class for which the compiler automatically adds certain
   behaviors that could also be provided manually—e.g. definitions of
   methods providing for deep comparisons and hashing, and destructuring a
   case class on its constructor parameters during pattern matching.)

   An example of a definition of the quicksort algorithm using pattern
   matching is as follows:
def qsort(list: List[Int]): List[Int] = list match {
  case Nil => Nil
  case pivot :: tail =>
    val (smaller, rest) = tail.partition(_ < pivot)
    qsort(smaller) ::: pivot :: qsort(rest)
}

   The idea here is that we partition a list into the elements less than a
   pivot and the elements not less, recursively sort each part, and paste
   the results together with the pivot in between. This uses the same
   divide-and-conquer strategy of mergesort and other fast sorting
   algorithms.

   The match operator is used to do pattern matching on the object stored
   in list. Each case expression is tried in turn to see if it will match,
   and the first match determines the result. In this case, Nil only
   matches the literal object Nil, but pivot :: tail matches a non-empty
   list, and simultaneously destructures the list according to the pattern
   given. In this case, the associated code will have access to a local
   variable named pivot holding the head of the list, and another variable
   tail holding the tail of the list. Note that these variables are
   read-only, and are semantically very similar to variable bindings
   established using the let operator in Lisp and Scheme.

   Pattern matching also happens in local variable declarations. In this
   case, the return value of the call to tail.partition is a tuple — in
   this case, two lists. (Tuples differ from other types of containers,
   e.g. lists, in that they are always of fixed size and the elements can
   be of differing types — although here they are both the same.) Pattern
   matching is the easiest way of fetching the two parts of the tuple.

   The form _ < pivot is a declaration of an anonymous function with a
   placeholder variable; see the section above on anonymous functions.

   The list operators :: (which adds an element onto the beginning of a
   list, similar to cons in Lisp and Scheme) and ::: (which appends two
   lists together, similar to append in Lisp and Scheme) both appear.
   Despite appearances, there is nothing "built-in" about either of these
   operators. As specified above, any string of symbols can serve as
   function name, and a method applied to an object can be written
   "infix"-style without the period or parentheses. The line above as
   written:

                qsort(smaller) ::: pivot :: qsort(rest)

   could also be written as follows:

                qsort(rest).::(pivot).:::(qsort(smaller))

   in more standard method-call notation. (Methods that end with a colon
   are right-associative and bind to the object to the right.)

Partial functions[edit]

   In the pattern-matching example above, the body of the match operator
   is a partial function, which consists of a series of case expressions,
   with the first matching expression prevailing, similar to the body of a
   switch statement. Partial functions are also used in the
   exception-handling portion of a try statement:
try {
  ...
} catch {
  case nfe:NumberFormatException => { println(nfe); List(0) }
  case _ => Nil
}

   Finally, a partial function can be used by itself, and the result of
   calling it is equivalent to doing a match over it. For example, the
   previous code for quicksort can be written as follows:
val qsort: List[Int] => List[Int] = {
  case Nil => Nil
  case pivot :: tail =>
    val (smaller, rest) = tail.partition(_ < pivot)
    qsort(smaller) ::: pivot :: qsort(rest)
}

   Here a read-only variable is declared whose type is a function from
   lists of integers to lists of integers, and bind it to a partial
   function. (Note that the single parameter of the partial function is
   never explicitly declared or named.) However, we can still call this
   variable exactly as if it were a normal function:
scala> qsort(List(6,2,5,9))
res32: List[Int] = List(2, 5, 6, 9)

Object-oriented extensions[edit]

   Scala is a pure object-oriented language in the sense that every value
   is an object. Data types and behaviors of objects are described by
   classes and traits. Class abstractions are extended by subclassing and
   by a flexible mixin-based composition mechanism to avoid the problems
   of multiple inheritance.

   Traits are Scala's replacement for Java's interfaces. Interfaces in
   Java versions under 8 are highly restricted, able only to contain
   abstract function declarations. This has led to criticism that
   providing convenience methods in interfaces is awkward (the same
   methods must be reimplemented in every implementation), and extending a
   published interface in a backwards-compatible way is impossible. Traits
   are similar to mixin classes in that they have nearly all the power of
   a regular abstract class, lacking only class parameters (Scala's
   equivalent to Java's constructor parameters), since traits are always
   mixed in with a class. The super operator behaves specially in traits,
   allowing traits to be chained using composition in addition to
   inheritance. The following example is a simple window system:
abstract class Window {
  // abstract
  def draw()
}

class SimpleWindow extends Window {
  def draw() {
    println("in SimpleWindow")
    // draw a basic window
  }
}

trait WindowDecoration extends Window { }

trait HorizontalScrollbarDecoration extends WindowDecoration {
  // "abstract override" is needed here in order for "super()" to work because t
he parent
  // function is abstract. If it were concrete, regular "override" would be enou
gh.
  abstract override def draw() {
    println("in HorizontalScrollbarDecoration")
    super.draw()
    // now draw a horizontal scrollbar
  }
}

trait VerticalScrollbarDecoration extends WindowDecoration {
  abstract override def draw() {
    println("in VerticalScrollbarDecoration")
    super.draw()
    // now draw a vertical scrollbar
  }
}

trait TitleDecoration extends WindowDecoration {
  abstract override def draw() {
    println("in TitleDecoration")
    super.draw()
    // now draw the title bar
  }
}

   A variable may be declared as follows:
val mywin = new SimpleWindow with VerticalScrollbarDecoration with HorizontalScr
ollbarDecoration with TitleDecoration

   The result of calling mywin.draw() is
in TitleDecoration
in HorizontalScrollbarDecoration
in VerticalScrollbarDecoration
in SimpleWindow

   In other words, the call to draw first executed the code in
   TitleDecoration (the last trait mixed in), then (through the super()
   calls) threaded back through the other mixed-in traits and eventually
   to the code in Window itself, even though none of the traits inherited
   from one another. This is similar to the decorator pattern, but is more
   concise and less error-prone, as it doesn't require explicitly
   encapsulating the parent window, explicitly forwarding functions whose
   implementation isn't changed, or relying on run-time initialization of
   entity relationships. In other languages, a similar effect could be
   achieved at compile-time with a long linear chain of implementation
   inheritance, but with the disadvantage compared to Scala that one
   linear inheritance chain would have to be declared for each possible
   combination of the mix-ins.

Expressive type system[edit]

   Scala is equipped with an expressive static type system that enforces
   the safe and coherent use of abstractions. In particular, the type
   system supports:
     * Classes and abstract types as object members
     * Structural types
     * Path-dependent types
     * Compound types
     * Explicitly typed self references
     * Generic classes
     * Polymorphic methods
     * Upper and lower type bounds
     * Variance
     * Annotation
     * Views

   Scala is able to infer types by usage. This makes most static type
   declarations optional. Static types need not be explicitly declared
   unless a compiler error indicates the need. In practice, some static
   type declarations are included for the sake of code clarity.

Type enrichment[edit]

   A common technique in Scala, known as "enrich my library" (formerly
   "pimp my library",^[22] now discouraged due to its connotation), allows
   new methods to be used as if they were added to existing types. This is
   similar to the C# concept of extension methods but more powerful,
   because the technique is not limited to adding methods and can for
   instance also be used to implement new interfaces. In Scala, this
   technique involves declaring an implicit conversion from the type
   "receiving" the method to a new type (typically, a class) that wraps
   the original type and provides the additional method. If a method
   cannot be found for a given type, the compiler automatically searches
   for any applicable implicit conversions to types that provide the
   method in question.

   This technique allows new methods to be added to an existing class
   using an add-on library such that only code that imports the add-on
   library gets the new functionality, and all other code is unaffected.

   The following example shows the enrichment of type Int with methods
   isEven and isOdd:
object MyExtensions {
  implicit class IntPredicates(i: Int) {
    def isEven = i % 2 == 0
    def isOdd  = !isEven
  }
}

import MyExtensions._  // bring implicit enrichment into scope
4.isEven  // -> true

   Importing the members of MyExtensions brings the implicit conversion to
   extension class IntPredicates into scope.^[26]

Concurrency[edit]

   Scala standard library includes support for the actor model, in
   addition to the standard Java concurrency APIs. Typesafe provides a
   stack^[27] that includes Akka,^[28] a separate open source framework
   that provides actor-based concurrency. Akka actors may be distributed
   or combined with software transactional memory ("transactors").
   Alternative CSP implementations for channel-based message passing are
   Communicating Scala Objects,^[29] or simply via JCSP.

   An Actor is like a thread instance with a mailbox. It can be created by
   system.actorOf, overriding the receive method to receive messages and
   using the ! (exclamation point) method to send a message.^[30] The
   following example shows an EchoServer which can receive messages and
   then print them.
val echoServer = actor(new Act {
  become {
    case msg => println("echo " + msg)
  }
})
echoServer ! "hi"

   Scala also comes with built-in support for data-parallel programming in
   the form of Parallel Collections ^[31] integrated into its Standard
   Library since version 2.9.0.

   The following example shows how to use Parallel Collections to improve
   performance.^[32]
val urls = List("http://scala-lang.org",  "https://github.com/scala/scala")

def fromURL(url: String) = scala.io.Source.fromURL(url)
  .getLines().mkString("\n")

val t = System.currentTimeMillis()
urls.par.map(fromURL(_))
println("time: " + (System.currentTimeMillis - t) + "ms")

Cluster computing[edit]

   Two significant cluster computing solutions are based on Scala: the
   open source Apache Spark and the commercial GridGain. Additionally,
   Apache Kafka, the publish-subscribe message queue popular with Spark
   and other stream processing technologies, is written in Scala.

Testing[edit]

   There are several ways to test code in Scala:
     * ScalaTest supports multiple testing styles and can integrate with
       Java-based testing frameworks
     * ScalaCheck, a library similar to Haskell's QuickCheck
     * specs2, a library for writing executable software specifications
     * ScalaMock provides support for testing high-order and curried
       functions
     * JUnit or TestNG, two popular testing frameworks written in Java

Versions[edit]

   Version Released Features Status Notes
   2.0 12-Mar-2006 _ _ _
   2.1.8 23-Aug-2006 _ _ _
   2.3.0 23-Nov-2006 _ _ _
   2.4.0 09-Mar-2007 _ _ _
   2.5.0 02-May-2007 _ _ _
   2.6.0 27-Jul-2007 _ _ _
   2.7.0 07-Feb-2008 _ _ _
   2.8.0 14-Jul-2010 Revision the common, uniform, and all-encompassing
   framework for collection types. _ _
   2.9.0 12-May-2011 _ _ _
   2.10 04-Jan-2013
     * Value Classes
     * Implicit Classes
     * String Interpolation
     * Futures and Promises
     * Dynamic and applyDynamic
     * Dependent method types: * def identity(x: AnyRef): x.type = x //
       the return type says we return exactly what we got
     * New ByteCode emitter based on ASM: Can target JDK 1.5, 1.6 and 1.7
       / Emits 1.6 bytecode by default / Old 1.5 backend is deprecated
     * A new Pattern Matcher: rewritten from scratch to generate more
       robust code (no more exponential blow-up!) / code generation and
       analyses are now independent (the latter can be turned off with
       -Xno-patmat-analysis)
     * Scaladoc Improvements
     * Implicits (-implicits flag)
     * Diagrams (-diagrams flag, requires graphviz)
     * Groups (-groups)
     * Modularized Language features
     * Parallel Collections are now configurable with custom thread pools
     * Akka Actors now part of the distribution\\scala.actors have been
       deprecated and the akka implementation is now included in the
       distribution.
     * Performance Improvements: Faster inliner / Range#sum is now O(1)
     * Update of ForkJoin library
     * Fixes in immutable TreeSet/TreeMap
     * Improvements to PartialFunctions
     * Addition of ??? and NotImplementedError
     * Addition of IsTraversableOnce + IsTraversableLike type classes for
       extension methods
     * Deprecations and cleanup
     * Floating point and octal literal syntax deprecation
     * Removed scala.dbc

   Experimental features
     * Scala Reflection
     * Macros

   _ _
   2.10.2 06-Jun-2013 _ _ _
   2.10.3 01-Oct-2013 _ _ _
   2.11.0 21-Apr-2014 _ _ _
   2.11.1 20-May-2014 _ _ _
   2.11.2 22-Jul-2014 _ Current _

Comparison with other JVM languages[edit]

   Scala is often compared with Groovy and Clojure, two other programming
   languages also using the JVM. Substantial differences between these
   languages are found in the type system, in the extent to which each
   language supports object-oriented and functional programming, and in
   the similarity of their syntax to the syntax of Java.

   Scala is statically typed, while both Groovy and Clojure are
   dynamically typed. This makes the type system more complex and
   difficult to understand but allows almost all type errors to be caught
   at compile-time and can result in significantly faster execution. By
   contrast, dynamic typing requires more testing to ensure program
   correctness and is generally slower in order to allow greater
   programming flexibility and simplicity. In regard to speed differences,
   current versions of Groovy and Clojure allow for optional type
   annotations to help programs avoid the overhead of dynamic typing in
   cases where types are practically static. This overhead is further
   reduced when using recent versions of the JVM, which has been enhanced
   with an "invoke dynamic" instruction for methods that are defined with
   dynamically typed arguments. These advances reduce the speed gap
   between static and dynamic typing, although a statically typed
   language, like Scala, is still the preferred choice when execution
   efficiency is very important.

   In regard to programming paradigms, Scala inherits the object-oriented
   model of Java and extends it in various ways. Groovy, while also
   strongly object-oriented is more focused in reducing verbosity. In
   Clojure, object-oriented programming is deemphasised with functional
   programming being the primary strength of the language. Scala also has
   many functional programming facilities, including features found in
   advanced functional languages like Haskell, and tries to be agnostic
   between the two paradigms, letting the developer choose between the two
   paradigms or, more frequently, some combination thereof.

   In regard to syntax similarity with Java, Scala inherits a lot of
   Java's syntax, as is the case with Groovy. Clojure on the other hand
   follows the Lisp syntax, which is very different in both appearance and
   philosophy, making the transition from Java very difficult. However,
   learning Scala is also considered difficult because of its many
   advanced features. This is not the case with Groovy, despite the fact
   that it is also a feature-rich language, mainly because it was designed
   to be primarily a scripting language.

Adoption[edit]

Language rankings[edit]

   Scala was voted the most popular JVM scripting language at the 2012
   JavaOne conference.^[10]

   As of 2013^[update], all JVM-based derivatives (Scala/Groovy/Clojure)
   are significantly less popular than the original Java language itself
   which is usually ranked first or second,^[33]^[34]^[35] and which is
   also simultaneously evolving over time.
   TIOBE Scala since 2006…2013‑06

   As of December 2013, the TIOBE index^[34] of programming language
   popularity shows Scala in 31st place with 0.342% of programmer
   mindshare (as measured by internet search engine rankings and similar
   publication-counting), while it was below the top 50 threshold the year
   before. Scala is now ahead of functional languages Haskell (50th) and
   Erlang (>50), as well as JVM competitors Groovy (47th) and Clojure
   (>50).

   Another measure, the RedMonk Programming Language Rankings, as of June
   2013 placed Scala 12th, based on 15th position in terms of number of
   GitHub projects and 16th in terms of number of questions tagged on
   Stack Overflow.^[33] (Groovy was 18th place; Clojure was 22nd.)^[33]
   Here, Scala is shown clearly behind a first-tier group of 11 languages
   (including Java, C, Python, PHP, Ruby, etc.), but leading a second-tier
   group.

   The ThoughtWorks Technology Radar, which is an opinion based
   half-yearly report of a group of senior technologists,^[36] recommends
   Scala adoption in its languages and frameworks category.^[37]

   According to Indeed.com Job Trends, Scala demand has been rapidly
   increasing since 2010, trending ahead of Clojure but behind Groovy.

Companies[edit]

   In April 2009, Twitter announced that it had switched large portions of
   its backend from Ruby to Scala and intended to convert the rest.^[38]

   Gilt uses Scala and Play Framework.^[39]

   Foursquare uses Scala and Lift.^[40]

   Coursera uses Scala and Play Framework.^[41]

   In April 2011, The Guardian newspaper's website guardian.co.uk
   announced that it was switching from Java to Scala,^[42] starting with
   the Content API for selecting and collecting news content.^[43] The
   website is one of the highest-traffic English-language news websites
   and, according to its editor, has the second largest online readership
   of any English-language newspaper in the World, after the New York
   Times.^[44] The New York Times itself revealed in 2014 that its
   internal content management system Blackbeard is built using Scala,
   Akka and Play.^[45] The Huffington Post newspaper has started to employ
   Scala as part of its contents delivery system Athena in 2013.^[46]

   Swiss bank UBS approved Scala for general production usage.^[47]

   LinkedIn uses the Scalatra microframework to power its Signal API.^[48]

   Meetup uses Unfiltered toolkit for real-time APIs.^[49]

   Remember the Milk uses Unfiltered toolkit, Scala and Akka for public
   API and real time updates.^[50]

   Verizon seeking to make "a next generation framework" using Scala.^[51]

Criticism[edit]

   In November, 2011, Yammer moved away from Scala for reasons that
   included the learning curve for new team members and incompatibility
   from one version of the Scala compiler to the next.^[52] Others
   criticize Scala for lack of readability regarding implicit parameters,
   that it is not possible to avoid Scala's more arcane features once one
   needs to pull in a library that uses them, and that overall, "Scala's
   difficulty outweighs its value."^[53]^[54]

See also[edit]

   Portal icon Free software portal
     * sbt, a widely used build tool for Scala projects.
     * Akka, a concurrency framework written in Scala.
     * Play!, an open source Web application framework that supports Scala
     * Circumflex, Web application and other frameworks for Scala
     * Lift, an open source Web application framework that aims to deliver
       benefits similar to Ruby on Rails. The use of Scala means that any
       existing Java library and Web container can be used in running Lift
       applications.
     * Scalatra, a very minimal Web application framework built using
       Scala

References[edit]

    1. ^ "Scala 2.11.2 is now available!". 2014-07-24. Retrieved
       2014-07-27.
    2. ^ "Scala 2.11.0-RC4 is now available!". 2014-04-08. Retrieved
       2014-04-21.
    3. ^ Fogus, Michael (6 August 2010). "MartinOdersky take(5) toList".
       Send More Paramedics. Retrieved 2012-02-09.
    4. ^ "Scala Macros".
    5. ^ ^a ^b ^c ^d Martin Odersky et al., An Overview of the Scala
       Programming Language, 2nd Edition
    6. ^ Odersky, Martin (2008). Programming in Scala. Mountain View,
       California: Artima. p. 3. ISBN 9780981531601. Retrieved 12 June
       2014.
    7. ^ Loverdo, Christos (2010). Steps in Scala: An Introduction to
       Object-Functional Programming. Cambridge University Press. p. xiii.
       ISBN 9781139490948. Retrieved 31 July 2014.
    8. ^ "Getting Started with Scala". scala-lang.org. 15 July 2008.
       Retrieved 31 July 2014.
    9. ^ ^a ^b ^c Martin Odersky, "A Brief History of Scala", Artima.com
       weblogs, June 9, 2006
   10. ^ ^a ^b ^c ^d ^e Odersky, M.; Rompf, T. (2014). "Unifying
       functional and object-oriented programming with Scala".
       Communications of the ACM 57 (4): 76. doi:10.1145/2591013.  edit
   11. ^ Martin Odersky, "The Scala Language Specification Version 2.7"
   12. ^ Expunged the .net backend. by paulp · Pull Request #1718 ·
       scala/scala · GitHub. Github.com (2012-12-05). Retrieved on
       2013-11-02.
   13. ^ Scala Team Wins ERC Grant
   14. ^ "Commercial Support for Scala". 2011-05-12. Retrieved
       2011-08-18.
   15. ^ "Why We Invested in Typesafe: Modern Applications Demand Modern
       Tools". 2011-05-12. Retrieved 2011-08-18.
   16. ^ "Open-source Scala gains commercial backing". 2011-05-12.
       Retrieved 2011-10-09.
   17. ^ "Cloud computing pioneer Martin Odersky takes wraps off his new
       company Typesafe". 2011-05-12. Retrieved 2011-08-24.
   18. ^ Scala IDE for Eclipse: Developing for Android
   19. ^ "Scala License | The Scala Programming Language". Scala-lang.org.
       Retrieved 2013-06-25.
   20. ^ "Home". Blog.lostlake.org. Retrieved 2013-06-25. ^[dead link]
   21. ^ Scala's built-in control structures such as if or while cannot be
       re-implemented. There is a research project, Scala-Virtualized,
       that aimed at removing these restrictions: Adriaan Moors, Tiark
       Rompf, Philipp Haller and Martin Odersky. Scala-Virtualized.
       Proceedings of the ACM SIGPLAN 2012 workshop on Partial evaluation
       and program manipulation, 117–120. July 2012.
   22. ^ ^a ^b "Pimp my Library". Artima.com. 2006-10-09. Retrieved
       2013-06-25.
   23. ^
       http://docs.scala-lang.org/overviews/collections/concrete-immutable
       -collection-classes.html
   24. ^ Tail calls, @tailrec and trampolines
   25. ^ "TailCalls - Scala Standard Library API (Scaladoc) 2.10.2 -
       scala.util.control.TailCalls". Scala-lang.org. Retrieved
       2013-06-25.
   26. ^ Implicit classes were introduced in Scala 2.10 to make method
       extensions more concise. This is equivalent to adding a method
       implicit def IntPredicate(i: Int) = new IntPredicate(i). The class
       can also be defined as implicit class IntPredicates(val i: Int)
       extends AnyVal { ... }, producing a so-called value class, also
       introduced in Scala 2.10. The compiler will then eliminate actual
       instantiations and generate static methods instead, allowing
       extension methods to have virtually no performance overhead.
   27. ^ Typesafe Inc. "Reactive – Typesafe Platform". Typesafe. Retrieved
       2013-06-25.
   28. ^ What is Akka?, Akka online documentation
   29. ^ Communicating Scala Objects, Bernard Sufrin, Communicating
       Process Architectures 2008
   30. ^ http://www.scala-tour.com/#/using-actor
   31. ^ "Parallelcollections - Overview - Scala Documentation".
       Docs.scala-lang.org. Retrieved 2013-06-25.
   32. ^ http://www.scala-tour.com/#/parallel-collection
   33. ^ ^a ^b ^c "The RedMonk Programming Language Rankings: June 2013".
   34. ^ ^a ^b "TIOBE Index for December 2013".
   35. ^ "The Transparent Language Popularity Index, July 2013".
   36. ^ "ThoughtWorks Technology Radar FAQ".
   37. ^ "ThoughtWorks Technology Radar MAY 2013".
   38. ^ Greene, Kate (April 1, 2009). "The Secret Behind Twitter's
       Growth, How a new Web programming language is helping the company
       handle its increasing popularity.". Technology Review. MIT.
       Retrieved April 6, 2009.
   39. ^ July 15, 2013 | Play Framework, Akka and Scala at Gilt Groupe |
       Typesafe
   40. ^ Scala, Lift, and the Future
   41. ^ Why we love Scala at Coursera
   42. ^ "Guardian switching from Java to Scala". Heise Online.
       2011-04-05. Retrieved 2011-04-05.
   43. ^ "Guardian.co.uk Switching from Java to Scala". InfoQ.com.
       2011-04-04. Retrieved 2011-04-05.
   44. ^ David Reid and Tania Teixeira (26 February 2010). "Are people
       ready to pay for online news?". BBC. Retrieved 2010-02-28.
   45. ^ Roy, Suman and Sundaresan, Krishna (2014-05-13). "Building
       Blackbeard: A Syndication System Powered By Play, Scala and Akka".
       Retrieved 2014-07-20.
   46. ^ Pavley, John (2013-08-11). "Sneak Peek: HuffPost Brings Real Time
       Collaboration to the Newsroom". Retrieved 2014-07-20.
   47. ^ Binstock, Andrew (2011-07-14). "Interview with Scala's Martin
       Odersky". Dr. Dobb's Journal. Retrieved 2012-02-10.
   48. ^ Synodinos, Dionysios G. (2010-10-11). "LinkedIn Signal: A Case
       Study for Scala, JRuby and Voldemort". InfoQ.
   49. ^ "Real-life Meetups Deserve Real-time APIs".
   50. ^ "Real time updating comes to the Remember The Milk web app".
   51. ^ "Senior Scala Engineer". Retrieved 2014-08-18.
   52. ^ Hale, Coda (29 November 2011). "The Rest of the Story".
       codahale.com. Retrieved 7 November 2013.
   53. ^ Allan, Graham (23 June 2013). "Using Scala Will Make You Less
       Productive". grundlefleck.github.io. Retrieved 7 November 2013.
   54. ^ Pollack, David (14 September 2011). "Scala use is less good than
       Java use for at least half of all Java projects". Retrieved 7
       November 2013.

Further reading[edit]

     * Suereth, Joshua D. (Spring 2011). Scala in Depth. Manning
       Publications. p. 225. ISBN 978-1-935182-70-2.
     * Meredith, Gregory (2011). Monadic Design Patterns for the Web (1st
       ed.). p. 300.
     * Raychaudhuri, Nilanjan (Fall 2011). Scala in Action (1st ed.).
       Manning. p. 525. ISBN 978-1-935182-75-7.
     * Wampler, Dean; Payne, Alex (September 15, 2009). Programming Scala:
       Scalability = Functional Programming + Objects (1st ed.). O'Reilly
       Media. p. 448. ISBN 0-596-15595-6.
     * Odersky, Martin; Spoon, Lex; Venners, Bill (December 13, 2010).
       Programming in Scala: A Comprehensive Step-by-step Guide (2nd ed.).
       Artima Inc. pp. 883/852. ISBN 978-0-9815316-4-9.
     * Pollak, David (May 25, 2009). Beginning Scala (1st ed.). Apress.
       p. 776. ISBN 1-4302-1989-0.
     * Perrett, Tim (July 2011). Lift in Action (1st ed.). Manning.
       p. 450. ISBN 978-1-935182-80-1.
     * Loverdos, Christos; Syropoulos, Apostolos (September 2010). Steps
       in Scala: An Introduction to Object-Functional Programming (1st
       ed.). Cambridge University Press. pp. xviii + 485.
       ISBN 978-0-521-74758-5.
     * Subramaniam, Venkat (July 28, 2009). Programming Scala: Tackle
       Multi-Core Complexity on the Java Virtual Machine (1st ed.).
       Pragmatic Bookshelf. p. 250. ISBN 1-934356-31-X.
     * Horstmann, Cay (March 2012). Scala for the Impatient (1st ed.).
       Addison-Wesley Professional. p. 360. ISBN 0-321-77409-4.

External links[edit]

   Wikibooks has a book on the topic of: Scala
     * Official website
     * Typesafe company website
     * Scala Forum
     * Scala communities around the globe
     * Scala IDE, open source Scala IDE for Eclipse
     * Scala Tour, open source Scala Tour
     * Interactive Tour, a tour of Scala


                                    * v
     * t
     * e

   Java
           Java platforms
                                    * Java language
                                    * JVM
                                    * Micro Edition
                                    * Standard Edition
                                    * Enterprise Edition
                                    * Java Card
                                    * Android SDK

                                                               Wave.svg
        Oracle technologies
                                    * Squawk
                                    * Java Development Kit
                                    * OpenJDK
                                    * Java virtual machine
                                    * JavaFX
                                    * Maxine VM

       Platform technologies
                                    * Applets
                                    * Servlets
                                    * MIDlets
                                    * JSP
                                    * Web Start (JNLP)

   Major third-party technologies
                                    * JRockit
                                    * GNU Classpath
                                    * Kaffe
                                    * TopLink
                                    * Apache Harmony
                                    * Apache Struts
                                    * Spring framework
                                    * Hibernate
                                    * JBoss application server
                                    * Tapestry
                                    * Jazelle

              History
                                    * Java version history
                                    * Java Community Process
                                    * Sun Microsystems
                                    * Free Java implementations

    Major programming languages
                                    * BeanShell
                                    * Clojure
                                    * Groovy
                                    * Oxygene
                                    * Java Tcl
                                    * JRuby
                                    * Jython
                                    * Processing
                                    * Rhino
                                    * Scala
                                    * more…

          Java conferences
                                    * JavaOne


                           * v
     * t
     * e

   Common Language Infrastructure
      Architecture
                        * Application domain
                        * Code Access Security
                        * Common Intermediate Language (CIL)
                             + CIL instructions
                        * Common Type System (CTS)
                        * Platform Invocation Services (P/Invoke)
                        * Virtual Execution System (VES)

       Components
                        * Assembly
                        * Delegate
                        * Manifest
                        * Metadata

   Standard Libraries

                      Kernel Profile
                                       * Base Class Library (BCL)
                                       * Runtime Infrastructure Library

                      Compact Profile
                                       * Network Library
                                       * Reflection Library
                                       * XML Library

                        * Extended Array Library
                        * Extended Numerics Library
                        * Parallel Library
                        * Vararg Library

    Implementations

                      Microsoft
                                 * .NET Framework
                                 * .NET Compact Framework
                                 * .NET Micro Framework
                                 * Shared Source Common Language Infrastructure

                        Other
                                 * Mono
                                 * Portable.NET

       Languages

                      Microsoft
                                  * C#
                                       + Visual C#
                                  * Visual Basic .NET
                                  * C++/CLI
                                       + Managed
                                  * F#
                                  * J#
                                  * JScript .NET
                                  * Windows PowerShell

                        Other
                                  * Axum
                                  * A#
                                  * Boo
                                  * Cobra
                                  * IronScheme (IronLisp)
                                  * IronPython
                                  * IronRuby
                                  * M
                                  * Nemerle
                                  * Oxygene
                                  * Phalanger
                                  * P#
                                  * Scala

                      Comparison
                                  * C# and Java
                                  * C# and Visual Basic .NET
                                  * Java and .NET platforms
                                  * Visual Basic and Visual Basic .NET

   Retrieved from
   "http://en.wikipedia.org/w/index.php?title=Scala_(programming_language)
   &oldid=624908310"
   Categories:
     * .NET programming languages
     * Concurrent programming languages
     * Java platform
     * Java programming language family
     * JVM programming languages
     * Functional languages
     * Object-oriented programming languages
     * Scala programming language
     * Scripting languages
     * Statically typed programming languages
     * 2003 introductions
     * Programming languages created in 2003
     * Programming languages created in the 2000s

   Hidden categories:
     * All articles with dead external links
     * Articles with dead external links from May 2014
     * All articles with unsourced statements
     * Articles with unsourced statements from June 2014
     * Articles needing additional references from June 2013
     * All articles needing additional references
     * Articles containing potentially dated statements from 2013
     * All articles containing potentially dated statements
     * Articles with example code

Navigation menu

Personal tools

     * Create account
     * Log in

Namespaces

     * Article
     * Talk

Variants

Views

     * Read
     * Edit
     * View history

More

Search

   ____________________ Search Go

Navigation

     * Main page
     * Contents
     * Featured content
     * Current events
     * Random article
     * Donate to Wikipedia
     * Wikimedia Shop

Interaction

     * Help
     * About Wikipedia
     * Community portal
     * Recent changes
     * Contact page

Tools

     * What links here
     * Related changes
     * Upload file
     * Special pages
     * Permanent link
     * Page information
     * Wikidata item
     * Cite this page

Print/export

     * Create a book
     * Download as PDF
     * Printable version

Languages

     * العربية
     * Azərbaycanca
     * Català
     * Čeština
     * Dansk
     * Deutsch
     * Ελληνικά
     * Español
     * Esperanto
     * فارسی
     * Français
     * Galego
     * 한국어
     * Italiano
     * עברית
     * Latviešu
     * Lietuvių
     * Nederlands
     * 日本語
     * Norsk bokmål
     * Polski
     * Português
     * Română
     * Русский
     * Suomi
     * Svenska
     * తెలుగు
     * Türkçe
     * Українська
     * Tiếng Việt
     * 中文
     *

   Edit links

     * This page was last modified on 10 September 2014 at 07:06.
     * Text is available under the Creative Commons Attribution-ShareAlike
       License; additional terms may apply. By using this site, you agree
       to the Terms of Use and Privacy Policy. Wikipedia® is a registered
       trademark of the Wikimedia Foundation, Inc., a non-profit
       organization.

     * Privacy policy
     * About Wikipedia
     * Disclaimers
     * Contact Wikipedia
     * Developers
     * Mobile view

     * Wikimedia Foundation
     * Powered by MediaWiki
